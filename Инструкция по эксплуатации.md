# OpenParticleLab Framework: Документация

<img width="1024" height="1024" alt="image" src="https://github.com/user-attachments/assets/915fb1ac-8355-4c27-a41b-5e697d10c345" />

## Назначение

OpenParticleLab Framework представляет собой интегрированную среду для моделирования физических процессов в ускорителях частиц и детекторах. Основные цели фреймворка:

- Симуляция столкновений частиц в коллайдерах с реалистичной физической моделью
- Моделирование траекторий частиц в магнитных полях с учетом релятивистских эффектов
- Анализ продуктов столкновений с использованием методов, аналогичных ROOT
- Визуализация экспериментальных установок и результатов в 2D и 3D
- Исследование как стандартных процессов Стандартной модели, так и гипотетических явлений за ее пределами
- Обучение основам физики высоких энергий и работы с коллайдерами

Фреймворк объединяет функциональность таких профессиональных инструментов, как Geant4, ROOT и MAD-X, но в более легковесной и доступной для обучения реализации, сохраняя при этом научную достоверность.

## Описание

OpenParticleLab Framework представляет собой модульную систему с четким разделением ответственности между компонентами:

### Основные компоненты

1. **ParticleDatabase** - расширенная база данных частиц с реальными физическими параметрами из Particle Data Group (2025):
   - Содержит полную информацию о массах, зарядах, спинах и времени жизни частиц
   - Включает данные о вероятностях распадов для нестабильных частиц
   - Поддерживает категоризацию частиц (лептоны, кварки, бозоны и т.д.)

2. **GeometryBuilder** - конструктор геометрии экспериментальных установок:
   - Позволяет определять компоненты: детекторы, магниты, мишени, пучковые трубы
   - Поддерживает загрузку геометрии из YAML-конфигурации
   - Обеспечивает 3D-визуализацию экспериментальной установки

3. **PhysicsEngine** - движок физических процессов с поддержкой различных теоретических моделей:
   - Стандартная модель физики частиц
   - Квантовая хромодинамика (QCD) для адронных столкновений
   - Электрослабая теория
   - Модель за пределами Стандартной модели (Beyong Standard Model)

4. **DetectorSimulator** - симулятор отклика детектора с учетом реальных характеристик:
   - Моделирует эффективность детектирования для разных типов частиц
   - Учитывает энергетическое и пространственное разрешение детекторов
   - Реализует реконструкцию событий с учетом шумов и неопределенности

5. **MagneticFieldSolver** - решатель магнитных полей и трассировки частиц:
   - Рассчитывает магнитное поле в любой точке пространства
   - Трассирует траектории частиц в магнитных полях
   - Поддерживает визуализацию линий магнитного поля

6. **DataAnalyzer** - анализатор данных с ROOT-подобным функционалом:
   - Создание и визуализация гистограмм (1D и 2D)
   - Фитирование данных (гауссианы, полиномы)
   - Определение областей интереса (ROI)
   - Экспорт результатов в ROOT-формат

7. **Visualizer** - система визуализации для 2D и 3D представления результатов:
   - Интерактивная 3D-визуализация с использованием Plotly
   - Диаграммы Фейнмана для визуализации процессов
   - Энергетические спектры и распределения
   - Динамические анимации процессов

8. **LHC_Model** - специализированная модель Большого адронного коллайдера:
   - Реалистичные параметры БАК на основе данных CERN
   - Симуляция динамики пучка с учетом эффектов пространственного заряда
   - Метод `step_simulation` для моделирования отдельных оборотов пучка
   - Визуализация параметров светимости и эмиттанса

### Архитектурные особенности

- **Модульность**: Каждый компонент может использоваться независимо
- **Гибкая конфигурация**: Поддержка YAML для описания экспериментов
- **Интеграция с профессиональными инструментами**: Возможность экспорта в ROOT
- **Расширяемость**: Простое добавление новых физических моделей и детекторов
- **Научная достоверность**: Использование реальных данных из Particle Data Group

## Инструкция по применению

<img width="1024" height="1024" alt="image" src="https://github.com/user-attachments/assets/436f1406-1a2b-4d69-b9db-ae575481c0ca" />

### 1. Установка зависимостей

```bash
pip install numpy matplotlib plotly pyyaml scipy
# Для ROOT-экспорта (опционально)
# pip install root-numpy root-pandas uproot
```

### 2. Создание конфигурационного файла эксперимента

Создайте файл `experiment.yml` с конфигурацией вашего эксперимента:

```yaml
beam:
  particle: "proton"
  energy: 6.5e12  # 6.5 ТэВ
target:
  particle: "proton"
geometry:
  - type: "detector"
    params:
      name: "ATLAS"
      position: [0, 0, 0]
      size: [46, 25, 25]
      efficiency: 0.99
      resolution: 0.01
      subdetectors:
        - name: "Inner Detector"
          radius: [0.05, 1.1]
          resolution: 0.01
          efficiency: 0.99
        - name: "Calorimeter"
          radius: [1.1, 4.3]
          resolution: 0.05
          efficiency: 0.95
        - name: "Muon Spectrometer"
          radius: [5.6, 11.0]
          resolution: 0.02
          efficiency: 0.90
      energy_resolution:
        electromagnetic: "lambda E: np.sqrt(0.03**2 + (0.005/E)**2)"
        hadronic: "lambda E: np.sqrt(0.1**2 + (0.03/E)**2)"
      tracking_resolution: "lambda pT: 0.007 * (1 + pT/150)"
  - type: "magnet"
    params:
      position: [0, 0, 0]
      orientation: [0, 0, 1]
      strength: 2.0  # Тесла
      type: "dipole"
      length: 5.0
      radius: 2.0
```

### 3. Запуск симуляции

```python
from open_particle_lab import OpenParticleLab

# Инициализация фреймворка
lab = OpenParticleLab()

# Загрузка конфигурации
lab.load_config('experiment.yml')

# Запуск симуляции
lab.run_simulation(num_events=1000, model='qcd')

# Анализ результатов
lab.analyze_results()

# Визуализация эксперимента
lab.visualize_experiment()

# Экспорт результатов
lab.export_results(format='json', path='results')
```

### 4. Использование специализированной модели LHC

```python
from open_particle_lab import LHC_Model

# Создание модели БАК
lhc = LHC_Model()

# Запуск полной симуляции
lhc.run_full_simulation(num_collisions=10)

# Симуляция одного оборота пучка
lhc.step_simulation()

# Симуляция 1000 оборотов пучка
lhc.run_simulation(num_turns=1000)

# Визуализация динамики пучка
lhc.visualize_beam_dynamics(num_turns=1000)

# Симуляция столкновения
events = lhc.simulate_collision(num_events=100)
```

### 5. Доступные методы и параметры

- **Методы симуляции**:
  - `run_simulation(num_turns, include_space_charge)`: Запуск полной симуляции
  - `step_simulation(include_space_charge)`: Симуляция одного оборота пучка
  - `simulate_collision(energy, num_events)`: Симуляция столкновений частиц
  - `simulate_particle_motion(num_turns, num_points)`: Симуляция траекторий

- **Методы анализа**:
  - `analyze_results()`: Автоматический анализ результатов симуляции
  - `create_histogram(name, data)`: Создание гистограммы
  - `fit_histogram(name, function)`: Фитирование гистограммы

- **Методы визуализации**:
  - `visualize_ring()`: Визуализация кольца коллайдера
  - `visualize_particle_motion()`: Визуализация движения частиц
  - `visualize_collision()`: Визуализация столкновения частиц
  - `visualize_beam_dynamics()`: Визуализация динамики пучка
  - `visualize_particle_decay(particle)`: Визуализация цепочки распада

## Примеры решения задач

### 1. Симуляция обнаружения бозона Хиггса

```python
# Создание модели БАК
lhc = LHC_Model()

# Симуляция 10000 событий для поиска бозона Хиггса
events = lhc.simulate_collision(num_events=10000)

# Фильтрация событий с производством бозона Хиггса
higgs_events = [e for e in events if e['event_type'] == 'higgs_boson_production']

print(f"Найдено {len(higgs_events)} событий с производством бозона Хиггса")

# Анализ распадов бозона Хиггса в b-кварки
b_quark_energies = []
for event in higgs_events:
    for product in event['products']:
        if product['name'] in ['bottom_quark', 'antibottom_quark']:
            b_quark_energies.append(product['energy'] / 1e9)  # в ГэВ

# Создание гистограммы энергии b-кварков
plt.figure(figsize=(10, 6))
plt.hist(b_quark_energies, bins=50, alpha=0.7, color='blue')
plt.axvline(x=62.5, color='red', linestyle='--', label='Ожидаемая энергия (62.5 ГэВ)')
plt.xlabel('Энергия b-кварка (ГэВ)')
plt.ylabel('Число событий')
plt.title('Распад бозона Хиггса в b-кварки')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.savefig('higgs_to_bquarks.png')
plt.show()

# Анализ инвариантной массы
invariant_masses = []
for event in higgs_events:
    b_quarks = [p for p in event['products'] 
               if p['name'] in ['bottom_quark', 'antibottom_quark']]
    if len(b_quarks) >= 2:
        # Упрощенный расчет инвариантной массы
        E1 = b_quarks[0]['energy']
        E2 = b_quarks[1]['energy']
        invariant_mass = np.sqrt(2 * E1 * E2) / 1e9  # в ГэВ
        invariant_masses.append(invariant_mass)

# Визуализация инвариантной массы
plt.figure(figsize=(10, 6))
plt.hist(invariant_masses, bins=30, alpha=0.7, color='green')
plt.axvline(x=125, color='red', linestyle='--', label='Масса Хиггса (125 ГэВ)')
plt.xlabel('Инвариантная масса (ГэВ)')
plt.ylabel('Число событий')
plt.title('Инвариантная масса пары b-кварков')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.savefig('higgs_invariant_mass.png')
plt.show()
```

### 2. Исследование динамики пучка с методом step_simulation

```python
# Создание модели БАК
lhc = LHC_Model()

# Инициализация начальных условий
initial_emittance = lhc.calculate_emittance(lhc.beam_energy)
lhc.simulation_state['beam_dynamics']['emittance'].append(initial_emittance)
lhc.simulation_state['beam_dynamics']['beam_intensity'].append(1.0)
lhc.simulation_state['beam_dynamics']['luminosity'].append(lhc.peak_luminosity)
lhc.simulation_state['luminosity'] = lhc.peak_luminosity

# Симуляция 500 оборотов пучка
num_turns = 500
for turn in range(num_turns):
    if turn % 50 == 0:
        print(f"Обработка оборота {turn+1}/{num_turns}")
    lhc.step_simulation()

# Визуализация результатов
plt.figure(figsize=(14, 10))

# 1. Рост эмиттанса
plt.subplot(2, 2, 1)
emittance = lhc.simulation_state['beam_dynamics']['emittance']
plt.plot(emittance)
plt.title('Рост эмиттанса пучка')
plt.xlabel('Номер оборота')
plt.ylabel('Эмиттанс (м·рад)')
plt.grid(True)

# 2. Изменение размеров пучка
plt.subplot(2, 2, 2)
beam_size_x = lhc.simulation_state['beam_dynamics']['beam_size_x']
beam_size_y = lhc.simulation_state['beam_dynamics']['beam_size_y']
plt.plot(beam_size_x, label='Горизонтальный размер')
plt.plot(beam_size_y, label='Вертикальный размер')
plt.title('Изменение размеров пучка')
plt.xlabel('Номер оборота')
plt.ylabel('Размер пучка (м)')
plt.yscale('log')
plt.legend()
plt.grid(True)

# 3. Светимость
plt.subplot(2, 2, 3)
luminosity = lhc.simulation_state['beam_dynamics']['luminosity']
plt.plot(luminosity)
plt.axhline(y=lhc.peak_luminosity, color='r', linestyle='--', label='Пиковая светимость')
plt.title('Светимость в зависимости от числа оборотов')
plt.xlabel('Номер оборота')
plt.ylabel('Светимость (см⁻²с⁻¹)')
plt.yscale('log')
plt.legend()
plt.grid(True)

# 4. Интенсивность пучка
plt.subplot(2, 2, 4)
intensity = lhc.simulation_state['beam_dynamics']['beam_intensity']
plt.plot(intensity)
plt.title('Интенсивность пучка')
plt.xlabel('Номер оборота')
plt.ylabel('Относительная интенсивность')
plt.grid(True)

plt.tight_layout()
plt.savefig('beam_dynamics_analysis.png')
plt.show()

# Анализ потерь светимости
initial_lum = lhc.peak_luminosity
final_lum = luminosity[-1]
loss_percentage = (initial_lum - final_lum) / initial_lum * 100
print(f"\nЗа {num_turns} оборотов светимость уменьшилась на {loss_percentage:.2f}%")
print(f"Конечная светимость: {final_lum:.2e} см⁻²с⁻¹")
print(f"Рост эмиттанса: {emittance[-1]/emittance[0]:.2f}x")
```

### 3. Поиск новых физических явлений при высоких энергиях

```python
# Создание модели БАК
lhc = LHC_Model()

# Установка энергии выше текущих возможностей БАК (15 ТэВ)
lhc.beam_energy = 7.5e12  # 7.5 ТэВ на пучок
lhc.center_of_mass_energy = 15e12  # 15 ТэВ в системе центра масс

# Симуляция 50000 событий для поиска новых физических явлений
events = lhc.simulate_collision(num_events=50000)

# Поиск событий с гипотетическими частицами
new_physics_events = [e for e in events 
                     if any(p['name'] in ['dark_matter', 'axion', 'graviton', 'extra_dimension'] 
                           for p in e['products'])]

print(f"Найдено {len(new_physics_events)} событий с признаками новой физики")

# Анализ событий с темной материей
dark_matter_events = [e for e in new_physics_events 
                     if any('dark_matter' in p['name'] for p in e['products'])]

if dark_matter_events:
    # Извлечение энергий темной материи
    dm_energies = []
    for event in dark_matter_events:
        for product in event['products']:
            if 'dark_matter' in product['name']:
                dm_energies.append(product['energy'] / 1e9)  # в ГэВ
    
    # Построение энергетического спектра
    plt.figure(figsize=(10, 6))
    plt.hist(dm_energies, bins=30, alpha=0.7, color='purple')
    plt.xlabel('Энергия темной материи (ГэВ)')
    plt.ylabel('Число событий')
    plt.title('Энергетический спектр темной материи')
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig('dark_matter_spectrum.png')
    plt.show()
    
    # Анализ инвариантной массы
    invariant_masses = []
    for event in dark_matter_events:
        # Предполагаем, что темная материя образуется в паре
        dm_particles = [p for p in event['products'] if 'dark_matter' in p['name']]
        if len(dm_particles) >= 2:
            # Упрощенный расчет инвариантной массы
            E1 = dm_particles[0]['energy']
            E2 = dm_particles[1]['energy']
            invariant_mass = np.sqrt(2 * E1 * E2) / 1e9  # в ГэВ
            invariant_masses.append(invariant_mass)
    
    # Построение распределения инвариантной массы
    if invariant_masses:
        plt.figure(figsize=(10, 6))
        plt.hist(invariant_masses, bins=25, alpha=0.7, color='darkred')
        plt.xlabel('Инвариантная масса (ГэВ)')
        plt.ylabel('Число событий')
        plt.title('Инвариантная масса пары частиц темной материи')
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.savefig('dark_matter_invariant_mass.png')
        plt.show()

# Визуализация типичного события с новой физикой
if new_physics_events:
    lhc.visualize_collision(energy=lhc.center_of_mass_energy)
```

### 4. Анализ распадов частиц и проверка физических моделей

```python
# Создание модели БАК
lhc = LHC_Model()

# Визуализация распада топ-кварка
lhc.visualize_particle_decay('top_quark')

# Статистический анализ распадов топ-кварка
num_simulations = 10000
decay_branches = []

for _ in range(num_simulations):
    decay_chain = lhc.simulate_particle_decay('top_quark')
    if len(decay_chain) > 1:
        decay_branches.append(decay_chain[1]['particle'])

# Подсчет вероятностей распада
from collections import Counter
branch_counts = Counter(decay_branches)
total = sum(branch_counts.values())

print("\nРезультаты симуляции распада топ-кварка:")
for particle, count in branch_counts.items():
    observed = count / total
    print(f"- {particle}: {observed:.4f} (наблюдаемая вероятность)")

# Сравнение с теоретическими ожиданиями
theoretical = {
    'w_boson': 0.999,
    'bottom_quark': 0.999
}

print("\nСравнение с теоретическими ожиданиями:")
for particle, theory_prob in theoretical.items():
    observed = branch_counts.get(particle, 0) / total
    deviation = abs(observed - theory_prob) / theory_prob * 100
    print(f"- {particle}: теория={theory_prob:.4f}, симуляция={observed:.4f}, отклонение={deviation:.2f}%")

# Визуализация распределения времени жизни
lifetimes = []
for _ in range(1000):
    decay_chain = lhc.simulate_particle_decay('muon')
    lifetimes.append(decay_chain[0]['remaining_lifetime'])

plt.figure(figsize=(10, 6))
plt.hist(lifetimes, bins=50, alpha=0.7, color='teal')
plt.axvline(x=2.1969811e-6, color='red', linestyle='--', 
           label='Табличное значение (2.1969811 мкс)')
plt.xlabel('Время жизни (с)')
plt.ylabel('Число событий')
plt.title('Распределение времени жизни мюона')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.savefig('muon_lifetime.png')
plt.show()

# Анализ распада бозона Хиггса
higgs_decays = []
for _ in range(5000):
    decay_chain = lhc.simulate_particle_decay('higgs_boson')
    if len(decay_chain) > 1:
        higgs_decays.append(decay_chain[1]['particle'])

higgs_branch_counts = Counter(higgs_decays)
higgs_total = sum(higgs_branch_counts.values())

# Построение круговой диаграммы
labels = []
sizes = []
for particle, count in higgs_branch_counts.items():
    fraction = count / higgs_total
    if fraction > 0.01:  # Фильтрация редких каналов
        labels.append(particle)
        sizes.append(fraction)

plt.figure(figsize=(10, 8))
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
plt.axis('equal')
plt.title('Вероятности распада бозона Хиггса')
plt.savefig('higgs_decay_branching.png')
plt.show()
```

## Заключение

OpenParticleLab Framework предоставляет мощную и гибкую платформу для моделирования физических процессов в коллайдерах. Его модульная архитектура и интуитивно понятный API позволяют как новичкам, так и опытным исследователям проводить сложные симуляции с минимальными усилиями.

Ключевые преимущества фреймворка:
- Научная достоверность благодаря использованию реальных данных
- Легкость настройки через YAML-конфигурации
- Глубокая интеграция с профессиональными инструментами анализа
- Расширенные возможности визуализации для лучшего понимания процессов
- Поддержка как стандартных, так и гипотетических физических моделей

Фреймворк идеально подходит для обучения, научных исследований и разработки новых методов анализа данных коллайдеров. С его помощью можно не только воспроизводить известные физические процессы, но и исследовать гипотетические явления за пределами Стандартной модели.
