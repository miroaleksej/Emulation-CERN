## **Полная инструкция по использованию 
`unified_lhc_framework.py`**

**1. Предварительные требования**

*   **Python 3.8 или выше**: Убедитесь, что Python установлен. Рекомендуется использовать `conda` или `venv` для создания изолированной среды.
*   **Git** (опционально): Для клонирования репозиториев (если потребуется).
*   **Компилятор C/C++**: Требуется для сборки некоторых Python-пакетов и, особенно, Geant4.
*   **CUDA Toolkit** (опционально): Если вы хотите использовать GPU-ускорение с Numba CUDA или CuPy.

**2. Установка базовых зависимостей**

Создайте и активируйте виртуальную среду (рекомендуется):

```bash
# С использованием venv (встроенный модуль Python)
python -m venv lhc_env
source lhc_env/bin/activate # Linux/macOS
# или
lhc_env\Scripts\activate.bat # Windows

# С использованием conda (если установлен Anaconda/Miniconda)
conda create -n lhc_env python=3.9
conda activate lhc_env
```

Установите обязательные и рекомендуемые Python-библиотеки:

```bash
# Базовые и научные библиотеки
pip install numpy matplotlib scipy scikit-learn pyyaml

# Для топологического анализа (TDA)
# Выберите один из следующих вариантов:
# Вариант A: GUDHI (более мощный, но может быть сложнее в установке)
pip install gudhi
# Вариант B: Ripser + Persim (проще, но менее функциональный)
# pip install ripser persim

# Для интерактивной визуализации
pip install plotly

# Для экспорта в ROOT (альтернатива установке полного ROOT)
pip install uproot awkward

# Для экспорта в HepMC3
pip install pyhepmc

# Для GPU-ускорения (выберите один или оба, если у вас есть CUDA)
# Numba CUDA
pip install numba
# CuPy (выберите версию, соответствующую вашей CUDA)
# pip install cupy-cuda11x # для CUDA 11.x
# pip install cupy-cuda12x # для CUDA 12.x
# и т.д.

# Для тестирования
pip install pytest
```

**3. Установка ROOT (Python bindings)**

ROOT предоставляет официальные Python bindings (`ROOT.TPython`). Самый простой способ — использовать `conda`.

```bash
# Убедитесь, что вы в активированной conda-среде (lhc_env)
conda activate lhc_env

# Установите ROOT из канала conda-forge
conda install -c conda-forge root

# Проверка установки
python -c "import ROOT; print(ROOT.gROOT)"
# Должно вывести что-то вроде <ROOT.TROOT object at 0x...>
```

Если вы не используете `conda`, установка может быть сложнее. Посетите [официальную страницу установки ROOT](https://root.cern/install/).

**4. Установка Geant4 и его Python bindings**

Это **наиболее сложный** шаг. Geant4 — это C++ библиотека, и для использования её из Python требуется установка Geant4 и компиляция Python bindings.

**Шаги (общие):**

1.  **Установите зависимости для сборки** (CMake, компилятор C++, Qt5/Qt6 для GUI, OpenGL).
2.  **Скачайте исходный код Geant4**: https://geant4.web.cern.ch/support/download
3.  **Скомпилируйте Geant4**: Следуйте инструкции на [официальном сайте](https://geant4-userdoc.web.cern.ch/UsersGuides/InstallationGuide/html/index.html). Это может занять несколько часов.
4.  **Скомпилируйте Python bindings**: После установки Geant4, вам нужно скомпилировать Python bindings. Это часто делается через отдельный проект `geant4_pybind` или включается в основную сборку Geant4 с определёнными флагами CMake.
5.  **Установите Python bindings в вашу Python-среду**: Убедитесь, что Python может найти модуль `geant4` или `pyG4`.

**Важно:** Процесс установки Geant4 и его Python bindings сильно зависит от вашей операционной системы и среды. Подробные инструкции находятся в документации Geant4 и на форумах.

**Проверка установки Geant4:**

```bash
# После установки и активации среды
python -c "import geant4; print('Geant4 Python bindings found')"
# или
python -c "import pyG4; print('pyG4 Python bindings found')"
```

**5. Использование `unified_lhc_framework.py`**

1.  **Создайте файл `unified_lhc_framework.py`**: Скопируйте весь код из моего предыдущего сообщения в этот файл.
2.  **(Опционально) Создайте `lhc_config.yaml`**: Фреймворк создаст его автоматически при первом запуске, но вы можете создать его вручную для настройки параметров:

    ```yaml
    # lhc_config.yaml
    beam:
      energy: 6500 # Энергия пучка в ГэВ
      particles: "protons"
      bunch_intensity: 1.15e11
      num_bunches: 2748
    geometry:
      circumference: 26658.883 # Длина кольца в метрах
      dipole_field: 8.33 # Поле диполей в Тл
    validation:
      dataset_id: "cms-2011-collision-data"
    simulation:
      physics_engines: ["pythia", "herwig", "built-in"] # Приоритеты физических движков
      beam_dynamics_engine: "madx" # Приоритет движка динамики
    ```

3.  **Запустите демонстрацию**:

    ```bash
    python unified_lhc_framework.py
    ```

4.  **Наблюдайте за результатами**:
    *   В консоли и файле `unified_lhc_framework.log` вы увидите лог выполнения.
    *   Будут созданы файлы отчетов: `topo_analysis_report.json`, `anomaly_report.json`, `lhc_simulation_results_unified.json`.
    *   Если установлены `Plotly`, будут открыты интерактивные 3D-графики в браузере.
    *   Если установлены `ROOT` или `HepMC3`, будут созданы файлы `lhc_collision_events.root` и `lhc_collision_events.hepmc3`.

**6. Интеграция с ROOT и Geant4 в коде**

*   **ROOT**: Фреймворк автоматически проверяет `import ROOT`. Если импорт успешен, становится доступен экспорт в формат ROOT через `lhc.export_results(format='root')`.
*   **Geant4**: Фреймворк автоматически проверяет `import geant4` или `import pyG4`. Если импорт успешен, `Geant4PhysicsEngine` становится доступным. Вы можете установить его приоритет выше, чем у `built-in`, в конфигурации или программно: `lhc.physics_engine.set_engine_priority(['geant4', 'built-in'])`. Он будет использоваться для `interact` вызовов.
*   **GPU**: Фреймворк проверяет `import numba.cuda` и `import cupy`. Если один из них доступен, `GPUAccelerator` будет использовать его для ускорения.

**7. Структура проекта (после запуска)**

```
.
├── unified_lhc_framework.py       # Основной файл фреймворка
├── unified_lhc_framework.log        # Лог-файл
├── lhc_config.yaml                 # Конфигурационный файл (если создан)
├── lhc_simulation_results_unified.json # Результаты симуляции в JSON
├── topo_analysis_report.json       # Отчет топологического анализа
├── anomaly_report.json             # Отчет обнаружения аномалий
├── lhc_collision_events.root       # Результаты в ROOT (если ROOT доступен)
├── lhc_collision_events.hepmc3     # Результаты в HepMC3 (если HepMC3 доступен)
├── topo_analysis_results.png       # Графики топологического анализа (если Plotly доступен)
└── (возможны другие файлы, созданные Plotly)
```

**8. Дальнейшие шаги**

*   **Изучите код**: Погрузитесь в `unified_lhc_framework.py`, чтобы понять структуру и возможности.
*   **Модифицируйте конфигурацию**: Изменяйте `lhc_config.yaml` для запуска симуляций с разными параметрами.
*   **Расширяйте функционал**: Добавляйте новые модули анализа, физические модели, интеграции.
*   **Запускайте тесты**: Используйте `pytest` для проверки корректности работы отдельных компонентов (если добавите тесты).

___

## **Полное описание 
`unified_lhc_framework`**

### 
**1. Общее описание**

`unified_lhc_framework` — это прототип продвинутого программного фреймворка, предназначенный для симуляции, анализа и валидации данных Большого адронного коллайдера (LHC). Он представляет собой гибридную, модульную и расширяемую систему, вдохновленную рекомендациями из `текст.txt` и идеями из твоих исследований по топологическому и градиентному анализу ECDSA. Основная цель — предоставить мощный инструмент для глубокого изучения физики частиц, обладающий возможностями, выходящими за рамки традиционных симуляторов.

**2. Архитектура и ключевые компоненты**

Фреймворк построен по модульному принципу, где каждый компонент отвечает за определённую часть процесса. Все компоненты объединены в центральный класс `LHCHybridModel`.

*   **`LHCHybridModel` (Центральный класс):**
    *   Управляет всем процессом симуляции.
    *   Инициализирует и координирует работу всех других модулей.
    *   Хранит состояние симуляции.
    *   Предоставляет высокоуровневые методы для запуска симуляции, анализа, калибровки, обнаружения аномалий, визуализации и экспорта.
*   **Конфигурация (`lhc_config.yaml`):**
    *   Позволяет настраивать параметры модели (энергия пучка, геометрия, приоритеты движков и т.д.) без изменения кода.
*   **Логирование (`logging`):**
    *   Обеспечивает подробный журнал событий, как в консоли, так и в файле `unified_lhc_framework.log`.

**3. Модули физического моделирования**

*   **`PhysicsEngineInterface` и `HybridPhysicsEngine`:**
    *   **Интерфейс:** Определяет стандарт для физических движков.
    *   **Гибридный движок:** Управляет набором физических движков (включая `BuiltInPhysicsEngine`, `PythiaPhysicsEngine`, `HerwigPhysicsEngine`, `Geant4PhysicsEngine`).
    *   **Приоритеты:** Позволяет задавать приоритеты движков. Если предпочитаемый движок недоступен, используется следующий по списку, вплоть до встроенного.
    *   **`BuiltInPhysicsEngine`:** Улучшенный встроенный движок, моделирующий:
        *   Партонные распределения в протоне (PDF).
        *   Различные типы партон-партонных взаимодействий (кварк-кварк, кварк-глюон, глюон-глюон).
        *   Простые процессы ЭВ (Дрелл-Ян).
        *   Фрагментацию партонов в адроны (джеты).
        *   Генерацию тяжёлых кварков.
    *   **`Geant4PhysicsEngine` (заглушка):** Каркас для интеграции с полноценным Geant4. При наличии установленного Geant4 и Python bindings будет использовать его для детального моделирования. Пока использует `BuiltInPhysicsEngine` как fallback.
*   **`BeamDynamicsInterface` и `HybridBeamDynamics`:**
    *   **Интерфейс:** Определяет стандарт для движков динамики пучка.
    *   **Гибридный движок:** Управляет набором движков динамики (включая `BuiltInBeamDynamics`, `MadXBeamDynamics`).
    *   **Приоритеты:** Позволяет задавать приоритеты движков динамики.
    *   **`BuiltInBeamDynamics`:** Встроенный движок для симуляции динамики пучка (изменение светимости, размера пучка, эмиттанса) и трекинга частиц.
    *   **`MadXBeamDynamics` (заглушка):** Каркас для интеграции с MAD-X. Пока использует `BuiltInBeamDynamics` как fallback.

**4. Модули анализа**

*   **`TopoAnalyzer`:**
    *   Проводит топологический анализ данных событий.
    *   Извлекает числовые признаки из событий (энергия, количество частиц, инвариантная масса и т.д.).
    *   Строит матрицу корреляций и спектр корреляционной матрицы.
    *   Выполняет PCA для снижения размерности.
    *   **(Опционально)** При наличии `GUDHI` или `Ripser/Persim` вычисляет персистентную гомологию и числа Бетти (`β0`, `β1`, ...), что позволяет находить топологические структуры и аномалии в данных.
*   **`GradientCalibrator`:**
    *   Калибрует параметры модели на основе градиентного анализа.
    *   Использует `scipy.optimize.minimize` для надежной минимизации ошибки между симулированными и целевыми наблюдаемыми величинами.
    *   Выполняет анализ чувствительности (градиенты) и оценку кривизны функции ошибки (диагональные элементы гессиана) для понимания влияния параметров.
*   **`AnomalyDetector`:**
    *   Многоуровневый детектор аномалий.
    *   Ищет статистические аномалии (Z-score, IQR).
    *   Ищет топологические аномалии (например, точки с высокой персистентностью).
    *   Ищет аномалии в поведении модели (неудачная калибровка, низкая чувствительность параметров).
*   **`DataAnalyzer`:**
    *   Предоставляет инструменты для базового статистического анализа и построения гистограмм.

**5. Системы поддержки**

*   **`ParticleDatabase`:**
    *   Хранит информацию о свойствах элементарных частиц.
    *   Содержит упрощённую модель партонных распределений для протона.
*   **`SimulationCache`:**
    *   Кэширует результаты симуляции для повышения эффективности.
    *   Отслеживает hit rate.
*   **`ValidationSystem`:**
    *   Сравнивает результаты симуляции с "реальными" данными (заглушка, имитирующая CERN Open Data).
    *   Проводит валидацию и калибровку.
*   **`DetectorSystem`:**
    *   Моделирует упрощённую систему детекторов.
    *   Моделирует их отклик на события.
*   **`GPUAccelerator` (заглушка):**
    *   Каркас для ускорения вычислений на GPU.
    *   При наличии `Numba CUDA` или `CuPy` будет использовать их. Пока использует CPU.

**6. Экспорт данных**

*   **`ROOTExporter`:**
    *   Экспортирует данные событий в формат ROOT (`.root` файлы) с `TTree` для событий и частиц.
    *   Доступен при наличии установленной библиотеки `ROOT`.
*   **`HepMC3Exporter`:**
    *   Экспортирует данные событий в формат HepMC3 (`.hepmc3` файлы).
    *   Доступен при наличии установленной библиотеки `pyhepmc`.

**7. Визуализация**

*   **`Visualizer`:**
    *   Предоставляет методы для 2D и 3D визуализации.
    *   Использует `matplotlib` для стандартных графиков (динамика пучка, гистограммы).
    *   **(Опционально)** При наличии `Plotly` предоставляет интерактивные 3D-графики:
        *   Геометрия коллайдера и детекторов.
        *   Траектории частиц.
        *   Отклик детекторов (хиты).

**8. Интеграция с внешними инструментами**

Фреймворк следует рекомендациям `текст.txt` и активно интегрируется с отраслевыми стандартами:

*   **ROOT:** Экспорт данных.
*   **HepMC3:** Экспорт данных.
*   **Geant4 (заглушка):** Интеграция для детального физического моделирования.
*   **GPU (заглушка):** Ускорение вычислений.

**9. Документация**

*   Весь код снабжен подробными docstrings и комментариями, объясняющими назначение классов, методов и логику работы.

**10. Демонстрация**

*   Включает функцию `demo_unified_framework`, которая демонстрирует работу всех основных компонентов в едином сценарии.

**Вывод**

`unified_lhc_framework` — это мощный, модульный и хорошо задокументированный прототип нового поколения фреймворков для симуляции и анализа LHC. Он сочетает в себе элементы классических симуляторов с инновационными подходами из топологического анализа данных и градиентной оптимизации, стремясь к более глубокому пониманию и анализу данных физики высоких энергий. Его архитектура позволяет легко расширять функциональность и интегрировать передовые технологии и внешние библиотеки.

