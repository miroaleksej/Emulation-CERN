# Гибридная система для точной и эффективной симуляции Большого адронного коллайдера

## Концепция гибридной системы

Представляю вам гибридную архитектуру, которая объединяет учебную модель с профессиональными инструментами, сохраняя доступность для обучения и обеспечивая максимальную точность. Эта система работает по принципу "правильные инструменты для правильных задач":

```python
# ===================================================================
# ГИБРИДНАЯ СИСТЕМА ДЛЯ ТОЧНОЙ СИМУЛЯЦИИ БАК
# ===================================================================
import numpy as np
import requests
import time
import logging
from typing import Dict, List, Tuple, Optional, Callable, Union
import os
import json
import warnings
from abc import ABC, abstractmethod

# Настройка логирования
logger = logging.getLogger("LHC_Hybrid")

# Попытка импорта профессиональных инструментов
try:
    import geant4
    GEANT4_AVAILABLE = True
    logger.info("Geant4 integration available")
except ImportError:
    GEANT4_AVAILABLE = False
    logger.warning("Geant4 not available. Using built-in simulation.")

try:
    import pythia8
    PYTHIA_AVAILABLE = True
    logger.info("PYTHIA integration available")
except ImportError:
    PYTHIA_AVAILABLE = False
    logger.warning("PYTHIA not available. Using built-in QCD model.")

try:
    import madx
    MADX_AVAILABLE = True
    logger.info("MADX integration available")
except ImportError:
    MADX_AVAILABLE = False
    logger.warning("MADX not available. Using built-in beam dynamics.")

# ===================================================================
# 1. Слой абстракции для интеграции с CERN Open Data
# ===================================================================
class CERN_Open_Data_API:
    """Интерфейс для работы с CERN Open Data API"""
    
    BASE_URL = "https://opendata.cern.ch/api/records"
    
    @staticmethod
    def get_lhc_parameters(timestamp: Optional[str] = None) -> Dict:
        """
        Получение реальных параметров БАК на заданный момент времени.
        Параметры:
        timestamp: временная метка (YYYY-MM-DDTHH:MM:SS)
        Возвращает:
        Словарь с параметрами БАК
        """
        params = {"q": "accelerator:LHC"}
        if timestamp:
            params["timestamp"] = timestamp
            
        try:
            response = requests.get(CERN_Open_Data_API.BASE_URL, params=params)
            response.raise_for_status()
            data = response.json()
            
            # Обработка данных и извлечение ключевых параметров
            lhc_params = {
                "circumference": 26658.883,  # Значение по умолчанию
                "beam_energy": 6.5e12,  # Значение по умолчанию
                "peak_luminosity": 2.0e34,  # Значение по умолчанию
                "beam_size_x": 16.7e-6,
                "beam_size_y": 16.7e-6,
                "protons_per_bunch": 2.2e11,
                "num_bunches": 2808,
                "magnetic_field": 8.33
            }
            
            # Здесь должна быть обработка реальных данных
            # Пример: если данные найдены, обновляем параметры
            if data.get("hits", {}).get("hits"):
                record = data["hits"]["hits"][0]
                # В реальной системе здесь обрабатывались бы данные из CERN Open Data
                # lhc_params["beam_energy"] = record["beam_energy"]
                
            return lhc_params
        except Exception as e:
            logger.warning(f"Error fetching CERN Open Data: {e}. Using default parameters.")
            return lhc_params
    
    @staticmethod
    def get_collision_data(dataset_id: str) -> Dict:
        """
        Получение реальных данных о столкновениях.
        Параметры:
        dataset_id: идентификатор набора данных
        Возвращает:
        Словарь с данными о столкновениях
        """
        try:
            url = f"{CERN_Open_Data_API.BASE_URL}/{dataset_id}"
            response = requests.get(url)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.warning(f"Error fetching collision data: {e}")
            return {}

# ===================================================================
# 2. Гибридные интерфейсы для профессиональных инструментов
# ===================================================================
class PhysicsEngineInterface(ABC):
    """Абстрактный интерфейс для физических движков"""
    
    @abstractmethod
    def interact(self, particle1: str, particle2: str, energy: float, 
                num_events: int = 1) -> List[Dict]:
        """Моделирование взаимодействия частиц"""
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        """Получение имени движка"""
        pass

class BuiltInPhysicsEngine(PhysicsEngineInterface):
    """Встроенная учебная модель физических процессов"""
    
    def __init__(self, particle_db):
        self.particle_db = particle_db
    
    def get_name(self) -> str:
        return "Built-in"
    
    def interact(self, particle1: str, particle2: str, energy: float, 
                num_events: int = 1) -> List[Dict]:
        """Учебная реализация моделирования взаимодействия"""
        # Здесь остается ваша текущая реализация
        # Можно добавить логирование использования учебной модели
        logger.debug("Using built-in physics engine for interaction simulation")
        # Ваша текущая реализация _get_collision_probabilities, _generate_collision_products и т.д.
        return []  # Заглушка

class Geant4PhysicsEngine(PhysicsEngineInterface):
    """Интеграция с Geant4 для детального моделирования взаимодействий"""
    
    def __init__(self, particle_db):
        self.particle_db = particle_db
        self.initialized = False
        self.geant4 = None
        
        if GEANT4_AVAILABLE:
            try:
                # Инициализация Geant4
                self.geant4 = geant4.initialize()
                self.initialized = True
                logger.info("Geant4 physics engine initialized successfully")
            except Exception as e:
                logger.error(f"Failed to initialize Geant4: {e}")
    
    def get_name(self) -> str:
        return "Geant4"
    
    def interact(self, particle1: str, particle2: str, energy: float, 
                num_events: int = 1) -> List[Dict]:
        if not self.initialized:
            logger.warning("Geant4 not initialized. Falling back to built-in engine.")
            return BuiltInPhysicsEngine(self.particle_db).interact(
                particle1, particle2, energy, num_events)
        
        try:
            # Подготовка данных для Geant4
            primary_particles = [
                {
                    "name": particle1,
                    "energy": energy / 2,
                    "momentum": [0, 0, energy / (2 * 3e8)]
                },
                {
                    "name": particle2,
                    "energy": energy / 2,
                    "momentum": [0, 0, -energy / (2 * 3e8)]
                }
            ]
            
            # Вызов Geant4
            results = self.geant4.simulate_collision(primary_particles, num_events)
            
            # Преобразование результатов в наш формат
            events = []
            for i, result in enumerate(results):
                event = {
                    "event_id": i,
                    "energy": energy,
                    "primary_particles": [particle1, particle2],
                    "products": [],
                    "timestamp": time.time()
                }
                
                for particle in result["final_state"]:
                    event["products"].append({
                        "name": particle["name"],
                        "energy": particle["energy"],
                        "momentum": particle["momentum"]
                    })
                
                events.append(event)
            
            return events
        except Exception as e:
            logger.error(f"Error in Geant4 simulation: {e}")
            return BuiltInPhysicsEngine(self.particle_db).interact(
                particle1, particle2, energy, num_events)

class PythiaPhysicsEngine(PhysicsEngineInterface):
    """Интеграция с PYTHIA для QCD процессов"""
    
    def __init__(self, particle_db):
        self.particle_db = particle_db
        self.initialized = False
        self.pythia = None
        
        if PYTHIA_AVAILABLE:
            try:
                # Инициализация PYTHIA
                self.pythia = pythia8.Pythia()
                self.initialized = True
                logger.info("PYTHIA physics engine initialized successfully")
            except Exception as e:
                logger.error(f"Failed to initialize PYTHIA: {e}")
    
    def get_name(self) -> str:
        return "PYTHIA"
    
    def interact(self, particle1: str, particle2: str, energy: float, 
                num_events: int = 1) -> List[Dict]:
        if not self.initialized:
            logger.warning("PYTHIA not initialized. Falling back to built-in engine.")
            return BuiltInPhysicsEngine(self.particle_db).interact(
                particle1, particle2, energy, num_events)
        
        try:
            # Настройка PYTHIA для pp-столкновений
            self.pythia.readString("Beams:eCM = {}".format(energy / 1e9))  # в ГэВ
            self.pythia.readString("HardQCD:all = on")
            self.pythia.init()
            
            events = []
            for i in range(num_events):
                if not self.pythia.next():
                    continue
                
                event = {
                    "event_id": i,
                    "energy": energy,
                    "primary_particles": [particle1, particle2],
                    "products": [],
                    "timestamp": time.time()
                }
                
                # Обработка частиц в событии
                for j in range(self.pythia.event.size()):
                    particle = self.pythia.event[j]
                    if particle.isFinal():
                        event["products"].append({
                            "name": self._convert_pythia_id(particle.id),
                            "energy": particle.e() * 1e9,  # конвертация в эВ
                            "momentum": [particle.px() * 1e9, particle.py() * 1e9, particle.pz() * 1e9]
                        })
                
                events.append(event)
            
            return events
        except Exception as e:
            logger.error(f"Error in PYTHIA simulation: {e}")
            return BuiltInPhysicsEngine(self.particle_db).interact(
                particle1, particle2, energy, num_events)
    
    def _convert_pythia_id(self, pythia_id: int) -> str:
        """Конвертация ID частиц PYTHIA в наши имена"""
        # Здесь должна быть таблица конвертации
        conversion = {
            2212: "proton",
            11: "electron",
            13: "muon",
            24: "w_boson",
            23: "z_boson",
            25: "higgs_boson",
            6: "top_quark",
            5: "bottom_quark"
        }
        return conversion.get(pythia_id, "unknown")

class HybridPhysicsEngine:
    """Гибридный движок, выбирающий подходящий движок для задачи"""
    
    def __init__(self, particle_db):
        self.particle_db = particle_db
        self.engines = {
            "built-in": BuiltInPhysicsEngine(particle_db),
            "geant4": Geant4PhysicsEngine(particle_db),
            "pythia": PythiaPhysicsEngine(particle_db)
        }
        self.preferred_engines = ["geant4", "pythia", "built-in"]
        logger.info("Hybrid physics engine initialized")
    
    def set_engine_priority(self, engine_names: List[str]):
        """
        Установка приоритета движков.
        Параметры:
        engine_names: список имен движков в порядке приоритета
        """
        self.preferred_engines = engine_names
        logger.info(f"Physics engine priority set to: {', '.join(engine_names)}")
    
    def interact(self, particle1: str, particle2: str, energy: float, 
                num_events: int = 1, force_engine: Optional[str] = None) -> List[Dict]:
        """
        Моделирование взаимодействия с выбором подходящего движка.
        Параметры:
        force_engine: принудительный выбор движка (если указан)
        """
        if force_engine and force_engine in self.engines:
            logger.info(f"Using forced engine: {force_engine}")
            return self.engines[force_engine].interact(
                particle1, particle2, energy, num_events)
        
        # Определение типа взаимодействия
        interaction_type = self._determine_interaction_type(particle1, particle2, energy)
        
        # Выбор подходящего движка на основе типа взаимодействия
        if interaction_type == "qcd" and "pythia" in self.preferred_engines:
            return self.engines["pythia"].interact(particle1, particle2, energy, num_events)
        elif "geant4" in self.preferred_engines:
            return self.engines["geant4"].interact(particle1, particle2, energy, num_events)
        else:
            return self.engines["built-in"].interact(particle1, particle2, energy, num_events)
    
    def _determine_interaction_type(self, p1: str, p2: str, energy: float) -> str:
        """Определение типа взаимодействия для выбора движка"""
        # QCD процессы для адронных столкновений
        if "quark" in p1 or "quark" in p2 or (p1 == "proton" and p2 == "proton"):
            return "qcd"
        # Электрослабые процессы
        elif "lepton" in self.particle_db.get_category(p1) or "lepton" in self.particle_db.get_category(p2):
            return "electroweak"
        # Общие процессы
        return "general"

# ===================================================================
# 3. Гибридные методы для динамики пучка
# ===================================================================
class BeamDynamicsInterface(ABC):
    """Абстрактный интерфейс для моделирования динамики пучка"""
    
    @abstractmethod
    def simulate_turn(self, state: Dict, revolution_time: float, 
                     include_space_charge: bool = True) -> Dict:
        """Симуляция одного оборота пучка"""
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        """Получение имени движка"""
        pass

class BuiltInBeamDynamics(BeamDynamicsInterface):
    """Встроенная учебная модель динамики пучка"""
    
    def get_name(self) -> str:
        return "Built-in"
    
    def simulate_turn(self, state: Dict, revolution_time: float, 
                     include_space_charge: bool = True) -> Dict:
        # Здесь остается ваша текущая реализация step_simulation
        logger.debug("Using built-in beam dynamics simulation")
        
        # Расчет времени одного оборота
        revolution_time = state['circumference'] / 3e8
        
        # Обновление общего времени симуляции
        state['time'] += revolution_time
        
        # Расчет количества столкновений за оборот
        current_luminosity = state.get('luminosity', state['peak_luminosity'])
        collision_rate = current_luminosity * 1e4  # светимость в см⁻²с⁻¹ → м⁻²с⁻¹
        num_collisions = int(collision_rate * revolution_time)
        
        # Обновление динамики пучка
        beam_dynamics = state['beam_dynamics']
        
        # Получение текущих параметров
        current_emittance = beam_dynamics['emittance'][-1] if beam_dynamics['emittance'] else 3.75e-6
        current_intensity = beam_dynamics['beam_intensity'][-1] if beam_dynamics['beam_intensity'] else 1.0
        
        # Эффекты пространственного заряда
        if include_space_charge:
            bunch_density = state['protons_per_bunch'] / (np.pi * state['beam_size_x'] * 
                                                        state['beam_size_y'] * state['bunch_length'])
            gamma = state['beam_energy'] / (938.272e6 * 1.602e-19)  # Упрощенный расчет
            space_charge_effect = 0.001 * bunch_density * (1/gamma**2) * current_intensity
            current_emittance *= (1 + space_charge_effect)
        
        # Потери частиц
        loss_rate = 0.0001
        current_intensity *= (1 - loss_rate)
        
        # Размеры пучка
        beta_function = 150
        sigma_x = np.sqrt(current_emittance * beta_function)
        sigma_y = np.sqrt(current_emittance * beta_function * 0.2)
        
        # Светимость
        current_luminosity = state['peak_luminosity'] * (state['beam_size_x'] / sigma_x)**2 * \
                            (state['beam_size_y'] / sigma_y)**2 * current_intensity
        
        # Обновление состояния
        beam_dynamics['emittance'].append(current_emittance)
        beam_dynamics['beam_size_x'].append(sigma_x)
        beam_dynamics['beam_size_y'].append(sigma_y)
        beam_dynamics['luminosity'].append(current_luminosity)
        beam_dynamics['beam_intensity'].append(current_intensity)
        
        # Обновление текущей светимости
        state['luminosity'] = current_luminosity
        
        return state

class MadXBeamDynamics(BeamDynamicsInterface):
    """Интеграция с MAD-X для точного моделирования динамики пучка"""
    
    def __init__(self):
        self.initialized = False
        self.madx = None
        
        if MADX_AVAILABLE:
            try:
                self.madx = madx.MADX()
                self.initialized = True
                logger.info("MADX beam dynamics engine initialized successfully")
            except Exception as e:
                logger.error(f"Failed to initialize MAD-X: {e}")
    
    def get_name(self) -> str:
        return "MADX"
    
    def simulate_turn(self, state: Dict, revolution_time: float, 
                     include_space_charge: bool = True) -> Dict:
        if not self.initialized:
            logger.warning("MADX not initialized. Falling back to built-in engine.")
            return BuiltInBeamDynamics().simulate_turn(state, revolution_time, include_space_charge)
        
        try:
            # Подготовка данных для MAD-X
            self.madx.command(f"beam, particle=proton, energy={state['beam_energy']/1e9};")
            self.madx.command(f"seqedit, sequence=LHC;")
            # Здесь должны быть команды для настройки последовательности
            
            # Симуляция одного оборота
            self.madx.command(f"twiss, file='twiss_output.dat';")
            
            # Чтение результатов
            with open("twiss_output.dat", "r") as f:
                twiss_data = f.read()
            
            # Обработка результатов и обновление состояния
            # Здесь должен быть код для извлечения данных из twiss_output.dat
            
            # Возвращаем обновленное состояние
            return state
        except Exception as e:
            logger.error(f"Error in MAD-X simulation: {e}")
            return BuiltInBeamDynamics().simulate_turn(state, revolution_time, include_space_charge)

class HybridBeamDynamics:
    """Гибридный движок для динамики пучка"""
    
    def __init__(self):
        self.engines = {
            "built-in": BuiltInBeamDynamics(),
            "madx": MadXBeamDynamics()
        }
        self.preferred_engines = ["madx", "built-in"]
        logger.info("Hybrid beam dynamics engine initialized")
    
    def set_engine_priority(self, engine_names: List[str]):
        """Установка приоритета движков"""
        self.preferred_engines = engine_names
        logger.info(f"Beam dynamics engine priority set to: {', '.join(engine_names)}")
    
    def simulate_turn(self, state: Dict, revolution_time: float, 
                     include_space_charge: bool = True, force_engine: Optional[str] = None) -> Dict:
        """Симуляция одного оборота с выбором подходящего движка"""
        if force_engine and force_engine in self.engines:
            logger.info(f"Using forced beam dynamics engine: {force_engine}")
            return self.engines[force_engine].simulate_turn(state, revolution_time, include_space_charge)
        
        # Выбор движка на основе доступности и приоритета
        for engine_name in self.preferred_engines:
            if engine_name in self.engines:
                return self.engines[engine_name].simulate_turn(state, revolution_time, include_space_charge)
        
        # Если ни один движок недоступен, используем встроенный
        return self.engines["built-in"].simulate_turn(state, revolution_time, include_space_charge)

# ===================================================================
# 4. Система валидации и калибровки
# ===================================================================
class ValidationSystem:
    """Система валидации симуляции против реальных данных"""
    
    def __init__(self, lhc_model):
        self.lhc_model = lhc_model
        self.validation_data = {}
        self.calibration_factors = {}
        logger.info("Validation system initialized")
    
    def load_real_data(self, dataset_id: str):
        """Загрузка реальных данных из CERN Open Data"""
        self.validation_data = CERN_Open_Data_API.get_collision_data(dataset_id)
        logger.info(f"Loaded real data from dataset {dataset_id}")
    
    def validate_luminosity(self) -> float:
        """Валидация светимости"""
        if not self.validation_data:
            logger.warning("No validation data loaded")
            return 0.0
        
        # Получение реальных данных о светимости
        real_luminosity = self._extract_real_luminosity()
        
        # Получение симулированной светимости
        sim_luminosity = self.lhc_model.simulation_state['luminosity']
        
        # Расчет относительной ошибки
        relative_error = abs(real_luminosity - sim_luminosity) / real_luminosity
        logger.info(f"Luminosity validation: real={real_luminosity:.2e}, sim={sim_luminosity:.2e}, error={relative_error:.2%}")
        
        return relative_error
    
    def validate_emittance(self) -> float:
        """Валидация эмиттанса"""
        if not self.validation_data:
            logger.warning("No validation data loaded")
            return 0.0
        
        # Получение реальных данных об эмиттансе
        real_emittance = self._extract_real_emittance()
        
        # Получение симулированного эмиттанса
        sim_emittance = self.lhc_model.simulation_state['beam_dynamics']['emittance'][-1]
        
        # Расчет относительной ошибки
        relative_error = abs(real_emittance - sim_emittance) / real_emittance
        logger.info(f"Emittance validation: real={real_emittance:.2e}, sim={sim_emittance:.2e}, error={relative_error:.2%}")
        
        return relative_error
    
    def calibrate_model(self):
        """Калибровка модели на основе реальных данных"""
        if not self.validation_data:
            logger.warning("No validation data to calibrate against")
            return
        
        # Расчет коэффициентов калибровки
        self.calibration_factors = {
            "luminosity": self._calculate_calibration_factor("luminosity"),
            "emittance": self._calculate_calibration_factor("emittance"),
            "beam_size": self._calculate_calibration_factor("beam_size")
        }
        
        logger.info("Model calibrated with factors:")
        for param, factor in self.calibration_factors.items():
            logger.info(f"  {param}: {factor:.4f}")
    
    def _calculate_calibration_factor(self, parameter: str) -> float:
        """Расчет коэффициента калибровки для параметра"""
        # Здесь должна быть логика для конкретного параметра
        if parameter == "luminosity":
            real_value = self._extract_real_luminosity()
            sim_value = self.lhc_model.simulation_state['luminosity']
        elif parameter == "emittance":
            real_value = self._extract_real_emittance()
            sim_value = self.lhc_model.simulation_state['beam_dynamics']['emittance'][-1]
        elif parameter == "beam_size":
            real_value = self._extract_real_beam_size()
            sim_value = self.lhc_model.simulation_state['beam_dynamics']['beam_size_x'][-1]
        else:
            return 1.0
        
        return real_value / sim_value if sim_value > 0 else 1.0
    
    def _extract_real_luminosity(self) -> float:
        """Извлечение реальной светимости из данных"""
        # В реальной системе здесь обрабатывались бы данные
        return 2.0e34  # Пример значения
    
    def _extract_real_emittance(self) -> float:
        """Извлечение реального эмиттанса из данных"""
        return 3.75e-6  # Пример значения
    
    def _extract_real_beam_size(self) -> float:
        """Извлечение реального размера пучка из данных"""
        return 16.7e-6  # Пример значения
    
    def apply_calibration(self, state: Dict) -> Dict:
        """Применение калибровки к состоянию симуляции"""
        if not self.calibration_factors:
            logger.info("No calibration factors available. Skipping calibration.")
            return state
        
        # Применение калибровочных коэффициентов
        state['luminosity'] *= self.calibration_factors.get('luminosity', 1.0)
        
        # Калибровка эмиттанса и размеров пучка
        beam_dynamics = state['beam_dynamics']
        if beam_dynamics['emittance']:
            beam_dynamics['emittance'][-1] *= self.calibration_factors.get('emittance', 1.0)
        
        if beam_dynamics['beam_size_x']:
            beam_dynamics['beam_size_x'][-1] *= np.sqrt(self.calibration_factors.get('beam_size', 1.0))
        
        if beam_dynamics['beam_size_y']:
            beam_dynamics['beam_size_y'][-1] *= np.sqrt(self.calibration_factors.get('beam_size', 1.0))
        
        return state

# ===================================================================
# 5. GPU-ускоренные вычисления
# ===================================================================
class GPU_Accelerator:
    """Система GPU-ускорения для критически важных вычислений"""
    
    def __init__(self):
        self.gpu_available = False
        self.numba_available = False
        self.cupy_available = False
        
        # Проверка доступности Numba
        try:
            from numba import cuda
            self.numba_available = True
            self.gpu_available = cuda.is_available()
            if self.gpu_available:
                logger.info("GPU acceleration via Numba available")
        except ImportError:
            pass
        
        # Проверка доступности CuPy
        try:
            import cupy
            self.cupy_available = True
            if self.gpu_available:
                logger.info("GPU acceleration via CuPy available")
        except ImportError:
            pass
    
    def track_particles_gpu(self, particles: List[Dict], field: Tuple, 
                           num_steps: int = 100, dt: float = 1e-9) -> List[List[Tuple]]:
        """GPU-ускоренная трассировка частиц"""
        if not self.gpu_available:
            logger.warning("GPU not available. Falling back to CPU tracking.")
            return self._track_particles_cpu(particles, field, num_steps, dt)
        
        try:
            if self.numba_available:
                return self._track_particles_numba(particles, field, num_steps, dt)
            elif self.cupy_available:
                return self._track_particles_cupy(particles, field, num_steps, dt)
        except Exception as e:
            logger.error(f"Error in GPU particle tracking: {e}")
            return self._track_particles_cpu(particles, field, num_steps, dt)
    
    def _track_particles_numba(self, particles: List[Dict], field: Tuple, 
                              num_steps: int, dt: float) -> List[List[Tuple]]:
        """Трассировка с использованием Numba CUDA"""
        from numba import cuda
        import numpy as np
        
        # Подготовка данных
        num_particles = len(particles)
        positions = np.zeros((num_particles, num_steps, 3), dtype=np.float32)
        momenta = np.zeros((num_particles, 3), dtype=np.float32)
        charges = np.zeros(num_particles, dtype=np.float32)
        
        for i, p in enumerate(particles):
            positions[i, 0, :] = p['position']
            momenta[i, :] = p['momentum']
            charges[i] = p['charge']
        
        # Перенос данных на GPU
        d_positions = cuda.to_device(positions)
        d_momenta = cuda.to_device(momenta)
        d_charges = cuda.to_device(charges)
        d_field = cuda.to_device(np.array(field, dtype=np.float32))
        
        # Ядро CUDA
        @cuda.jit
        def particle_tracking_kernel(positions, momenta, charges, field, dt):
            i = cuda.grid(1)
            if i < positions.shape[0]:
                for step in range(1, positions.shape[1]):
                    # Упрощенная модель для примера
                    px, py, pz = momenta[i, 0], momenta[i, 1], momenta[i, 2]
                    charge = charges[i]
                    Bx, By, Bz = field[0], field[1], field[2]
                    
                    # F = q(v × B), упрощенно p ≈ v
                    fx = charge * (py * Bz - pz * By)
                    fy = charge * (pz * Bx - px * Bz)
                    fz = charge * (px * By - py * Bx)
                    
                    # Обновление импульса
                    px += fx * dt
                    py += fy * dt
                    pz += fz * dt
                    momenta[i, 0], momenta[i, 1], momenta[i, 2] = px, py, pz
                    
                    # Обновление позиции
                    positions[i, step, 0] = positions[i, step-1, 0] + px * dt
                    positions[i, step, 1] = positions[i, step-1, 1] + py * dt
                    positions[i, step, 2] = positions[i, step-1, 2] + pz * dt
        
        # Запуск ядра
        threads_per_block = 256
        blocks = (num_particles + threads_per_block - 1) // threads_per_block
        particle_tracking_kernel[blocks, threads_per_block](d_positions, d_momenta, d_charges, d_field, dt)
        
        # Получение результатов
        cuda.synchronize()
        result = d_positions.copy_to_host()
        
        # Преобразование в исходный формат
        tracks = []
        for i in range(num_particles):
            track = [(result[i, step, 0], result[i, step, 1], result[i, step, 2]) 
                    for step in range(num_steps)]
            tracks.append(track)
        
        return tracks
    
    def _track_particles_cupy(self, particles: List[Dict], field: Tuple, 
                             num_steps: int, dt: float) -> List[List[Tuple]]:
        """Трассировка с использованием CuPy"""
        import cupy as cp
        import numpy as np
        
        # Подготовка данных
        num_particles = len(particles)
        positions = cp.zeros((num_particles, num_steps, 3), dtype=cp.float32)
        momenta = cp.zeros((num_particles, 3), dtype=cp.float32)
        charges = cp.zeros(num_particles, dtype=cp.float32)
        
        for i, p in enumerate(particles):
            positions[i, 0, :] = cp.array(p['position'])
            momenta[i, :] = cp.array(p['momentum'])
            charges[i] = p['charge']
        
        # Константы
        field_gpu = cp.array(field, dtype=cp.float32)
        
        # Векторизованные вычисления
        for step in range(1, num_steps):
            # Вычисление силы F = q(v × B)
            vx, vy, vz = momenta[:, 0], momenta[:, 1], momenta[:, 2]
            Bx, By, Bz = field_gpu[0], field_gpu[1], field_gpu[2]
            
            fx = charges * (vy * Bz - vz * By)
            fy = charges * (vz * Bx - vx * Bz)
            fz = charges * (vx * By - vy * Bx)
            
            # Обновление импульса
            momenta[:, 0] += fx * dt
            momenta[:, 1] += fy * dt
            momenta[:, 2] += fz * dt
            
            # Обновление позиции
            positions[:, step, 0] = positions[:, step-1, 0] + momenta[:, 0] * dt
            positions[:, step, 1] = positions[:, step-1, 1] + momenta[:, 1] * dt
            positions[:, step, 2] = positions[:, step-1, 2] + momenta[:, 2] * dt
        
        # Получение результатов
        result = cp.asnumpy(positions)
        
        # Преобразование в исходный формат
        tracks = []
        for i in range(num_particles):
            track = [(result[i, step, 0], result[i, step, 1], result[i, step, 2]) 
                    for step in range(num_steps)]
            tracks.append(track)
        
        return tracks
    
    def _track_particles_cpu(self, particles: List[Dict], field: Tuple, 
                            num_steps: int, dt: float) -> List[List[Tuple]]:
        """CPU-версия трассировки (для сравнения и fallback)"""
        tracks = []
        for p in particles:
            positions = []
            x, y, z = p['position']
            px, py, pz = p['momentum']
            charge = p['charge']
            
            for _ in range(num_steps):
                # F = q(v × B), упрощенно p ≈ v
                fx = charge * (py * field[2] - pz * field[1])
                fy = charge * (pz * field[0] - px * field[2])
                fz = charge * (px * field[1] - py * field[0])
                
                # Обновление импульса
                px += fx * dt
                py += fy * dt
                pz += fz * dt
                
                # Обновление позиции
                x += px * dt
                y += py * dt
                z += pz * dt
                
                positions.append((x, y, z))
            
            tracks.append(positions)
        
        return tracks

# ===================================================================
# 6. Кэширование и оптимизация
# ===================================================================
class SimulationCache:
    """Система кэширования результатов симуляции"""
    
    def __init__(self, max_size: int = 1000):
        self.cache = {}
        self.max_size = max_size
        self.access_count = 0
        self.hit_count = 0
        logger.info(f"Simulation cache initialized with max size {max_size}")
    
    def get(self, key: str) -> Optional[Dict]:
        """Получение результатов из кэша"""
        self.access_count += 1
        if key in self.cache:
            self.hit_count += 1
            hit_rate = self.hit_count / self.access_count
            logger.debug(f"Cache hit for key '{key}'. Hit rate: {hit_rate:.2%}")
            return self.cache[key]
        return None
    
    def set(self, key: str, value: Dict):
        """Сохранение результатов в кэш"""
        if len(self.cache) >= self.max_size:
            # Удаление самого старого элемента
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]
        
        self.cache[key] = value
        logger.debug(f"Added to cache with key '{key}'")
    
    def clear(self):
        """Очистка кэша"""
        self.cache.clear()
        self.access_count = 0
        self.hit_count = 0
        logger.info("Simulation cache cleared")
    
    def get_hit_rate(self) -> float:
        """Получение текущего hit rate"""
        return self.hit_count / self.access_count if self.access_count > 0 else 0.0
    
    @staticmethod
    def generate_key(params: Dict) -> str:
        """Генерация уникального ключа на основе параметров"""
        # Сортировка ключей для консистентности
        sorted_items = sorted(params.items())
        # Создание строки с параметрами
        param_str = ",".join([f"{k}={v}" for k, v in sorted_items])
        # Хеширование для компактности
        return str(hash(param_str))

# ===================================================================
# 7. Обновленная модель LHC с гибридной архитектурой
# ===================================================================
class Hybrid_LHC_Model:
    """Гибридная модель Большого адронного коллайдера"""
    
    def __init__(self):
        """Инициализация гибридной модели БАК"""
        # Загрузка реальных параметров из CERN Open Data
        self.cern_params = CERN_Open_Data_API.get_lhc_parameters()
        
        # Основные параметры БАК
        self.circumference = self.cern_params["circumference"]
        self.radius = self.circumference / (2 * np.pi)
        self.beam_energy = self.cern_params["beam_energy"]
        self.center_of_mass_energy = 2 * self.beam_energy
        self.peak_luminosity = self.cern_params["peak_luminosity"]
        self.beam_size_x = self.cern_params["beam_size_x"]
        self.beam_size_y = self.cern_params["beam_size_y"]
        self.protons_per_bunch = self.cern_params["protons_per_bunch"]
        self.num_bunches = self.cern_params["num_bunches"]
        
        # Инициализация компонентов
        self.particle_db = ParticleDatabase()
        self.physics_engine = HybridPhysicsEngine(self.particle_db)
        self.beam_dynamics = HybridBeamDynamics()
        self.validation_system = ValidationSystem(self)
        self.gpu_accelerator = GPU_Accelerator()
        self.simulation_cache = SimulationCache()
        
        # Инициализация состояния симуляции
        self.simulation_state = {
            'time': 0.0,
            'luminosity': self.peak_luminosity,
            'collisions': [],
            'detected_particles': [],
            'beam_dynamics': {
                'emittance': [],
                'beam_size_x': [],
                'beam_size_y': [],
                'luminosity': [],
                'beam_intensity': []
            }
        }
        
        # Загрузка калибровочных данных (если доступно)
        self._load_calibration_data()
        
        logger.info("Hybrid LHC model initialized with CERN parameters")
    
    def _load_calibration_data(self):
        """Загрузка данных для калибровки из файла"""
        try:
            with open("calibration_data.json", "r") as f:
                calibration_data = json.load(f)
                self.validation_system.calibration_factors = calibration_data
            logger.info("Calibration data loaded from file")
        except (FileNotFoundError, json.JSONDecodeError):
            logger.info("No calibration data found. Using default calibration.")
    
    def save_calibration_data(self):
        """Сохранение калибровочных данных в файл"""
        try:
            with open("calibration_data.json", "w") as f:
                json.dump(self.validation_system.calibration_factors, f, indent=2)
            logger.info("Calibration data saved to file")
        except Exception as e:
            logger.error(f"Error saving calibration data: {e}")
    
    def step_simulation(self, include_space_charge: bool = True, 
                      force_physics_engine: Optional[str] = None,
                      force_beam_engine: Optional[str] = None):
        """
        Симуляция одного оборота пучка с использованием гибридной системы.
        
        Параметры:
        include_space_charge: учитывать ли эффекты пространственного заряда
        force_physics_engine: принудительный выбор физического движка
        force_beam_engine: принудительный выбор движка динамики пучка
        """
        start_time = time.time()
        
        # 1. Расчет времени одного оборота
        revolution_time = self.circumference / 3e8
        
        # 2. Обновление общего времени симуляции
        self.simulation_state['time'] += revolution_time
        
        # 3. Расчет количества столкновений за оборот
        current_luminosity = self.simulation_state.get('luminosity', self.peak_luminosity)
        collision_rate = current_luminosity * 1e4  # светимость в см⁻²с⁻¹ → м⁻²с⁻¹
        num_collisions = int(collision_rate * revolution_time)
        
        # 4. Симуляция столкновений
        if num_collisions > 0:
            logger.info(f"Simulating {num_collisions} collisions for this revolution")
            
            # Проверка кэша
            cache_key = SimulationCache.generate_key({
                "energy": self.center_of_mass_energy,
                "num_collisions": num_collisions,
                "engine": force_physics_engine or "auto"
            })
            cached_result = self.simulation_cache.get(cache_key)
            
            if cached_result:
                collisions = cached_result
            else:
                # Симуляция столкновений с использованием гибридного движка
                collisions = self.physics_engine.interact(
                    "proton", "proton", self.center_of_mass_energy, 
                    num_events=num_collisions,
                    force_engine=force_physics_engine
                )
                self.simulation_cache.set(cache_key, collisions)
            
            self.simulation_state['collisions'].extend(collisions)
        
        # 5. Обновление динамики пучка
        # Создание состояния для передачи в движок динамики
        state = {
            'circumference': self.circumference,
            'beam_energy': self.beam_energy,
            'peak_luminosity': self.peak_luminosity,
            'beam_size_x': self.beam_size_x,
            'beam_size_y': self.beam_size_y,
            'protons_per_bunch': self.protons_per_bunch,
            'bunch_length': self.calculate_bunch_length(),
            'luminosity': self.simulation_state['luminosity'],
            'time': self.simulation_state['time'],
            'beam_dynamics': self.simulation_state['beam_dynamics']
        }
        
        # Симуляция оборота с использованием гибридного движка
        updated_state = self.beam_dynamics.simulate_turn(
            state, revolution_time, include_space_charge, 
            force_engine=force_beam_engine
        )
        
        # Применение калибровки
        calibrated_state = self.validation_system.apply_calibration(updated_state)
        
        # Обновление состояния симуляции
        self.simulation_state['luminosity'] = calibrated_state['luminosity']
        self.simulation_state['beam_dynamics'] = calibrated_state['beam_dynamics']
        
        # Логирование результатов
        elapsed = time.time() - start_time
        logger.info(f"Completed revolution in {elapsed:.4f} seconds")
        logger.info(f"  Luminosity: {self.simulation_state['luminosity']:.2e} cm⁻²s⁻¹")
        logger.info(f"  Emittance: {self.simulation_state['beam_dynamics']['emittance'][-1]:.2e} m·rad")
    
    def run_simulation(self, num_turns: int = 1000, 
                     include_space_charge: bool = True,
                     physics_engine: str = "auto",
                     beam_engine: str = "auto"):
        """
        Запуск симуляции на заданное количество оборотов.
        
        Параметры:
        num_turns: количество оборотов для симуляции
        include_space_charge: учитывать ли эффекты пространственного заряда
        physics_engine: выбор физического движка ('auto', 'geant4', 'pythia', 'built-in')
        beam_engine: выбор движка динамики пучка ('auto', 'madx', 'built-in')
        """
        logger.info(f"Starting simulation for {num_turns} turns")
        start_time = time.time()
        
        # Установка приоритетов движков
        if physics_engine != "auto":
            self.physics_engine.set_engine_priority([physics_engine, "built-in"])
        if beam_engine != "auto":
            self.beam_dynamics.set_engine_priority([beam_engine, "built-in"])
        
        # Инициализация начальных условий
        initial_emittance = 3.75e-6  # Нормированный эмиттанс для БАК
        self.simulation_state['beam_dynamics']['emittance'].append(initial_emittance)
        self.simulation_state['beam_dynamics']['beam_intensity'].append(1.0)
        self.simulation_state['beam_dynamics']['luminosity'].append(self.peak_luminosity)
        self.simulation_state['luminosity'] = self.peak_luminosity
        
        # Выполнение симуляции
        for turn in range(num_turns):
            if turn % 100 == 0:
                logger.info(f"Processing turn {turn+1}/{num_turns}")
            self.step_simulation(
                include_space_charge,
                force_physics_engine=physics_engine if physics_engine != "auto" else None,
                force_beam_engine=beam_engine if beam_engine != "auto" else None
            )
        
        elapsed = time.time() - start_time
        logger.info(f"Simulation completed in {elapsed:.2f} seconds "
                   f"({num_turns/elapsed:.2f} turns/sec)")
        
        # Валидация результатов
        self.validate_results()
        
        return self.simulation_state['beam_dynamics']
    
    def validate_results(self):
        """Валидация результатов симуляции"""
        logger.info("Validating simulation results against real data...")
        
        # Загрузка реальных данных для валидации
        self.validation_system.load_real_data("CMS-EXO-16-022")
        
        # Валидация ключевых параметров
        luminosity_error = self.validation_system.validate_luminosity()
        emittance_error = self.validation_system.validate_emittance()
        
        # Калибровка модели на основе результатов валидации
        if luminosity_error > 0.1 or emittance_error > 0.1:
            logger.info("Significant errors detected. Calibrating model...")
            self.validation_system.calibrate_model()
            self.save_calibration_data()
    
    def calculate_bunch_length(self) -> float:
        """Расчет длины сгустка"""
        return 3e8 * 25e-9  # c * bunch_spacing
    
    def track_particles(self, particles: List[Dict], field: Tuple, 
                      num_steps: int = 100, dt: float = 1e-9) -> List[List[Tuple]]:
        """
        Трассировка частиц с использованием GPU-ускорения при возможности.
        
        Параметры:
        particles: список частиц для трассировки
        field: магнитное поле (Bx, By, Bz)
        num_steps: количество шагов трассировки
        dt: временной шаг
        """
        return self.gpu_accelerator.track_particles_gpu(particles, field, num_steps, dt)

# ===================================================================
# 8. Пример использования гибридной системы
# ===================================================================
if __name__ == "__main__":
    logger.info("="*70)
    logger.info("ЗАПУСК ГИБРИДНОЙ СИСТЕМЫ СИМУЛЯЦИИ БОЛЬШОГО АДРОННОГО КОЛЛАЙДЕРА")
    logger.info("="*70)
    
    # Создание гибридной модели
    lhc = Hybrid_LHC_Model()
    
    # Запуск симуляции с использованием различных движков
    logger.info("\nСценарий 1: Автоматический выбор движков")
    lhc.run_simulation(num_turns=100)
    
    if GEANT4_AVAILABLE or PYTHIA_AVAILABLE:
        logger.info("\nСценарий 2: Использование Geant4/PYTHIA для физики")
        lhc.run_simulation(num_turns=50, physics_engine="geant4" if GEANT4_AVAILABLE else "pythia")
    
    if MADX_AVAILABLE:
        logger.info("\nСценарий 3: Использование MAD-X для динамики пучка")
        lhc.run_simulation(num_turns=50, beam_engine="madx")
    
    logger.info("\nСценарий 4: Полностью учебная модель (без внешних зависимостей)")
    lhc.run_simulation(num_turns=50, physics_engine="built-in", beam_engine="built-in")
    
    logger.info("="*70)
    logger.info("ГИБРИДНАЯ СИСТЕМА СИМУЛЯЦИИ ЗАВЕРШИЛА РАБОТУ")
    logger.info("="*70)
```

## Ключевые преимущества гибридной системы

### 1. Интеллектуальная интеграция профессиональных инструментов

Система автоматически выбирает наиболее подходящий инструмент для каждой задачи:
- **Geant4** для детального моделирования взаимодействий частиц с материей
- **PYTHIA** для QCD процессов и адронных столкновений
- **MAD-X** для точного моделирования динамики пучка
- **Встроенная модель** для учебных целей и когда внешние инструменты недоступны

```python
# Автоматический выбор движка
lhc.run_simulation(num_turns=100)

# Принудительное использование Geant4
lhc.run_simulation(num_turns=50, physics_engine="geant4")
```

### 2. Система валидации и калибровки

Гибридная система автоматически сравнивает результаты симуляции с реальными данными из CERN Open Data и корректирует модель:

```python
def validate_results(self):
    """Валидация результатов симуляции"""
    self.validation_system.load_real_data("CMS-EXO-16-022")
    luminosity_error = self.validation_system.validate_luminosity()
    
    # Автоматическая калибровка при значительных ошибках
    if luminosity_error > 0.1:
        self.validation_system.calibrate_model()
```

### 3. GPU-ускорение критических вычислений

Система использует Numba или CuPy для ускорения трассировки частиц в магнитных полях:

```python
def track_particles_gpu(self, particles: List[Dict], field: Tuple, 
                       num_steps: int = 100, dt: float = 1e-9) -> List[List[Tuple]]:
    """GPU-ускоренная трассировка частиц"""
    if self.numba_available:
        return self._track_particles_numba(particles, field, num_steps, dt)
    elif self.cupy_available:
        return self._track_particles_cupy(particles, field, num_steps, dt)
```

### 4. Система кэширования для повышения эффективности

Гибридная система кэширует результаты симуляции для повторяющихся параметров, значительно ускоряя последующие запуски:

```python
def step_simulation(self, include_space_charge: bool = True):
    # Проверка кэша
    cache_key = SimulationCache.generate_key({
        "energy": self.center_of_mass_energy,
        "num_collisions": num_collisions
    })
    cached_result = self.simulation_cache.get(cache_key)
    
    if not cached_result:
        # Выполнение симуляции
        collisions = self.physics_engine.interact(...)
        self.simulation_cache.set(cache_key, collisions)
```

### 5. Гибкая конфигурация для различных сценариев использования

Система поддерживает несколько режимов работы:
- **Профессиональный режим**: Использование Geant4, PYTHIA и MAD-X для максимальной точности
- **Учебный режим**: Встроенная модель с подробными пояснениями для обучения
- **Гибридный режим**: Смешанное использование инструментов для оптимального баланса точности и скорости

```python
# Профессиональный режим
lhc.run_simulation(num_turns=100, physics_engine="geant4", beam_engine="madx")

# Учебный режим
lhc.run_simulation(num_turns=100, physics_engine="built-in", beam_engine="built-in")

# Гибридный режим (автоматический выбор)
lhc.run_simulation(num_turns=100)
```

## Практическое применение

### 1. Для студентов и преподавателей

Гибридная система идеально подходит для обучения, предоставляя:
- Доступ к реальным данным CERN через Open Data API
- Возможность сравнения учебной модели с профессиональными инструментами
- Подробные пояснения при использовании учебного режима

```python
# Учебный режим с подробными пояснениями
lhc.run_simulation(num_turns=10, physics_engine="built-in", beam_engine="built-in")
```

### 2. Для исследователей

Система позволяет:
- Быстро проверять гипотезы с использованием профессиональных инструментов
- Сравнивать результаты с реальными данными
- Выполнять предварительный анализ перед запуском ресурсоемких симуляций

```python
# Профессиональный режим с валидацией
lhc.run_simulation(num_turns=1000, physics_engine="geant4", beam_engine="madx")
lhc.validate_results()
```

### 3. Для разработчиков детекторов

Гибридная система обеспечивает:
- Точное моделирование отклика детектора с использованием Geant4
- Возможность анализа влияния различных параметров детектора
- Интеграцию с реальными геометриями детекторов из CERN

```python
# Интеграция с реальной геометрией детектора
detector_geometry = CERN_Open_Data_API.get_detector_geometry("ATLAS")
simulation = run_detector_simulation(detector_geometry, physics_engine="geant4")
```

## Заключение

Представленная гибридная система представляет собой мощный инструмент, который:
1. Сохраняет образовательную ценность нашей текущей реализации
2. Добавляет профессиональную точность через интеграцию с Geant4, PYTHIA и MAD-X
3. Обеспечивает автоматическую валидацию и калибровку на основе реальных данных CERN
4. Ускоряет вычисления с помощью GPU и системы кэширования
5. Предоставляет гибкую конфигурацию для различных сценариев использования

Эта система не требует полной переработки вашего учебного кода - она интегрируется с существующей реализацией через слой абстракции, сохраняя всю текущую функциональность и добавляя профессиональные возможности при их доступности.

Такой подход превращает вашу учебную модель в действительно полезный инструмент, который может использоваться как для обучения, так и для предварительного анализа в реальных научных исследованиях.
